// Code generated by go-swagger; DO NOT EDIT.

package document

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new document API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for document API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	DocDelete(params *DocDeleteParams, opts ...ClientOption) (*DocDeleteOK, *DocDeleteAccepted, error)

	DocGet(params *DocGetParams, opts ...ClientOption) (*DocGetOK, error)

	DocInfo(params *DocInfoParams, opts ...ClientOption) (*DocInfoOK, error)

	DocPut(params *DocPutParams, opts ...ClientOption) (*DocPutCreated, *DocPutAccepted, error)

	Post(params *PostParams, opts ...ClientOption) (*PostCreated, *PostAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  DocDelete marks the specified document as deleted by adding a field deleted with the value true

  Documents with this field will not be returned within requests anymore, but stay in the database.
You must supply the current (latest) revision, either by using the rev parameter or by using the
If-Match header to specify the revision.

*Notes*
CouchDB doesnâ€™t completely delete the specified document. Instead, it leaves a tombstone with very
basic information about the document. The tombstone is required so that the delete action can be
replicated across databases.

*/
func (a *Client) DocDelete(params *DocDeleteParams, opts ...ClientOption) (*DocDeleteOK, *DocDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "docDelete",
		Method:             "DELETE",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocDeleteReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DocDeleteOK:
		return value, nil, nil
	case *DocDeleteAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for document: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocGet returns document by the specified docid from the specified db unless you request a specific revision the latest revision of the document will always be returned
*/
func (a *Client) DocGet(params *DocGetParams, opts ...ClientOption) (*DocGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "docGet",
		Method:             "GET",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "multipart/mixed", "multipart/related", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "multipart/mixed", "multipart/related", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocInfo returns the HTTP headers containing a minimal amount of information about the specified document

  The method supports the same query arguments as the GET /{db}/{docid} method,
but only the header information (including document size, and the revision as an ETag), is returned.

The ETag header shows the current revision for the requested document, and the Content-Length
specifies the length of the data, if the document were requested in full.

Adding any of the query arguments (see GET /{db}/{docid}), then the resulting HTTP Headers
will correspond to what would be returned.

*/
func (a *Client) DocInfo(params *DocInfoParams, opts ...ClientOption) (*DocInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "docInfo",
		Method:             "HEAD",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docInfo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocPut thes p u t method creates a new named document or creates a new revision of the existing document unlike the p o s t db you must specify the document ID in the request URL

  When updating an existing document, the current document revision must be included in the document
(i.e. the request body), as the rev query parameter, or in the If-Match request header.

*/
func (a *Client) DocPut(params *DocPutParams, opts ...ClientOption) (*DocPutCreated, *DocPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocPutParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "docPut",
		Method:             "PUT",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocPutReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DocPutCreated:
		return value, nil, nil
	case *DocPutAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for document: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Post creates a new document in the specified database using the supplied JSON document structure

  If the JSON structure includes the _id field, then the document will be created with the
specified document ID.

If the _id field is not specified, a new unique ID will be generated, following whatever
UUID algorithm is configured for that server.

*/
func (a *Client) Post(params *PostParams, opts ...ClientOption) (*PostCreated, *PostAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "post",
		Method:             "POST",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostCreated:
		return value, nil, nil
	case *PostAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for document: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
